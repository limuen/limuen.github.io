(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{563:function(s,o,e){"use strict";e.r(o);var i=e(13),_=Object(i.a)({},(function(){var s=this,o=s.$createElement,e=s._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"_1、什么是认证-authentication"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是认证-authentication"}},[s._v("#")]),s._v(" 1、什么是认证（Authentication）")]),s._v(" "),e("ul",[e("li",[s._v("通俗地讲就是"),e("strong",[s._v("验证当前用户的身份")]),s._v("，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）")]),s._v(" "),e("li",[s._v("互联网中的认证\n"),e("ul",[e("li",[s._v("用户名密码登录")]),s._v(" "),e("li",[s._v("邮箱发送登录链接")]),s._v(" "),e("li",[s._v("手机号接收验证码")]),s._v(" "),e("li",[s._v("只要你能收到邮箱/验证码，就默认你是账号的主人")])])])]),s._v(" "),e("h2",{attrs:{id:"_2、什么是授权-authorization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是授权-authorization"}},[s._v("#")]),s._v(" 2、什么是授权（Authorization）")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("用户授予第三方应用访问该用户某些资源的权限")]),s._v(" "),e("ul",[e("li",[s._v("你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）")]),s._v(" "),e("li",[s._v("你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）")])])]),s._v(" "),e("li",[s._v("实现授权的方式有：cookie、session、token、OAuth")])]),s._v(" "),e("h2",{attrs:{id:"_3、什么是凭证-credentials"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是凭证-credentials"}},[s._v("#")]),s._v(" 3、什么是凭证（Credentials）")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("实现认证和授权的前提")]),s._v("是需要一种媒介（证书） 来标记访问者的身份\n"),e("ul",[e("li",[s._v("在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。")]),s._v(" "),e("li",[s._v("在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是"),e("strong",[s._v("认证的凭证")]),s._v("。")]),s._v(" "),e("li",[s._v("在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。")])])])]),s._v(" "),e("h2",{attrs:{id:"_4、什么是-cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、什么是-cookie"}},[s._v("#")]),s._v(" 4、什么是 Cookie")]),s._v(" "),e("ul",[e("li",[e("p",[e("strong",[s._v("HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息")]),s._v("）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("cookie 存储在客户端")]),s._v("： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("cookie 是不可跨域的")]),s._v("： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，"),e("strong",[s._v("一级域名和二级域名之间是允许共享使用的（靠的是 domain）")]),s._v("。")])])]),s._v(" "),e("h3",{attrs:{id:"cookie-重要的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-重要的属性"}},[s._v("#")]),s._v(" cookie 重要的属性")]),s._v(" "),e("p",[e("img",{attrs:{src:"/cookie.jpg",alt:"avatar"}})]),s._v(" "),e("h2",{attrs:{id:"_5、什么是-session"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、什么是-session"}},[s._v("#")]),s._v(" 5、什么是 Session")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("session 是另一种记录服务器和客户端会话状态的机制")])]),s._v(" "),e("li",[e("strong",[s._v("session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中")])])]),s._v(" "),e("p",[e("img",{attrs:{src:"/session.jpg",alt:"avatar"}})]),s._v(" "),e("ul",[e("li",[s._v("session 认证流程：\n"),e("ul",[e("li",[s._v("用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session")]),s._v(" "),e("li",[s._v("请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器")]),s._v(" "),e("li",[s._v("浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名")]),s._v(" "),e("li",[s._v("当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。")])])])]),s._v(" "),e("p",[s._v("根据以上流程可知，"),e("strong",[s._v("SessionID 是连接 Cookie 和 Session 的一道桥梁")]),s._v("，大部分系统也是根据此原理来验证用户登录状态。")]),s._v(" "),e("h3",{attrs:{id:"cookie-和-session-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别"}},[s._v("#")]),s._v(" Cookie 和 Session 的区别")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("安全性：")]),s._v(" Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。")]),s._v(" "),e("li",[e("strong",[s._v("存取值的类型不同：")]),s._v(" Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。")]),s._v(" "),e("li",[e("strong",[s._v("有效期不同：")]),s._v(" Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。")]),s._v(" "),e("li",[e("strong",[s._v("存储大小不同：")]),s._v(" 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。")])]),s._v(" "),e("h2",{attrs:{id:"_6、什么是-token-令牌"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、什么是-token-令牌"}},[s._v("#")]),s._v(" 6、什么是 Token（令牌）")]),s._v(" "),e("h3",{attrs:{id:"acesss-token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#acesss-token"}},[s._v("#")]),s._v(" Acesss Token")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("访问资源接口（API）时所需要的资源凭证")])]),s._v(" "),e("li",[e("strong",[s._v("简单 token 的组成：")]),s._v(" uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）")]),s._v(" "),e("li",[e("strong",[s._v("特点：")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("服务端无状态化、可扩展性好")])]),s._v(" "),e("li",[e("strong",[s._v("支持移动端设备")])]),s._v(" "),e("li",[s._v("安全")]),s._v(" "),e("li",[s._v("支持跨程序调用")])])]),s._v(" "),e("li",[e("strong",[s._v("token 的身份验证流程：")]),s._v(" "),e("img",{attrs:{src:"/token.jpg",alt:"avatar"}})])]),s._v(" "),e("h3",{attrs:{id:"refresh-token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#refresh-token"}},[s._v("#")]),s._v(" Refresh Token")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("另外一种 token——refresh token")])]),s._v(" "),e("li",[e("p",[s._v("refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。")]),s._v(" "),e("p",[e("img",{attrs:{src:"/Refresh.jpg",alt:"avatar"}})])]),s._v(" "),e("li",[e("p",[s._v("Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。")])]),s._v(" "),e("li",[e("p",[s._v("Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。")])])]),s._v(" "),e("h3",{attrs:{id:"token-和-session-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token-和-session-的区别"}},[s._v("#")]),s._v(" Token 和 Session 的区别")]),s._v(" "),e("ul",[e("li",[s._v("Session 是一种"),e("strong",[s._v("记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信")]),s._v("息。而 Token 是"),e("strong",[s._v("令牌，访问资源接口（API）时所需要的资源凭证")]),s._v("。Token 使"),e("strong",[s._v("服务端无状态化，不会存储会话信息")]),s._v("。")]),s._v(" "),e("li",[s._v("Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。"),e("strong",[s._v("如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态")]),s._v("。")]),s._v(" "),e("li",[s._v("所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说："),e("strong",[s._v("如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了")]),s._v("。")])]),s._v(" "),e("h2",{attrs:{id:"_7、常见的前后端鉴权方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、常见的前后端鉴权方式"}},[s._v("#")]),s._v(" 7、常见的前后端鉴权方式")]),s._v(" "),e("ol",[e("li",[s._v("Session-Cookie")]),s._v(" "),e("li",[s._v("Token 验证")]),s._v(" "),e("li",[s._v("OAuth2.0（开放授权）")])]),s._v(" "),e("h2",{attrs:{id:"_8、常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、常见问题"}},[s._v("#")]),s._v(" 8、常见问题")]),s._v(" "),e("h3",{attrs:{id:"使用-cookie-时需要考虑的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-cookie-时需要考虑的问题"}},[s._v("#")]),s._v(" 使用 cookie 时需要考虑的问题")]),s._v(" "),e("ul",[e("li",[s._v("因为存储在客户端，容易被客户端篡改，使用前需要验证合法性")]),s._v(" "),e("li",[s._v("不要存储敏感数据，比如用户密码，账户余额")]),s._v(" "),e("li",[s._v("使用 httpOnly 在一定程度上提高安全性")]),s._v(" "),e("li",[s._v("尽量减少 cookie 的体积，能存储的数据量不能超过 4kb")]),s._v(" "),e("li",[s._v("设置正确的 domain 和 path，减少数据传输")]),s._v(" "),e("li",[e("strong",[s._v("cookie 无法跨域")])]),s._v(" "),e("li",[s._v("一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie")]),s._v(" "),e("li",[e("strong",[s._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),s._v(" "),e("h3",{attrs:{id:"使用-session-时需要考虑的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-session-时需要考虑的问题"}},[s._v("#")]),s._v(" 使用 session 时需要考虑的问题")]),s._v(" "),e("ul",[e("li",[s._v("将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session")]),s._v(" "),e("li",[s._v("当网站采用"),e("strong",[s._v("集群部署")]),s._v("的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。")]),s._v(" "),e("li",[s._v("当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。")]),s._v(" "),e("li",[e("strong",[s._v("sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？")]),s._v(" 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现")]),s._v(" "),e("li",[e("strong",[s._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),s._v(" "),e("h3",{attrs:{id:"使用-token-时需要考虑的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-token-时需要考虑的问题"}},[s._v("#")]),s._v(" 使用 token 时需要考虑的问题")]),s._v(" "),e("ul",[e("li",[s._v("如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。")]),s._v(" "),e("li",[e("strong",[s._v("token 完全由应用管理，所以它可以避开同源策略")])]),s._v(" "),e("li",[e("strong",[s._v("token 可以避免 CSRF 攻击(因为不需要 cookie 了)")])]),s._v(" "),e("li",[e("strong",[s._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),s._v(" "),e("h3",{attrs:{id:"只要关闭浏览器-session-真的就消失了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#只要关闭浏览器-session-真的就消失了"}},[s._v("#")]),s._v(" 只要关闭浏览器 ，session 真的就消失了？")]),s._v(" "),e("p",[s._v("不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。")]),s._v(" "),e("p",[s._v("然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。")]),s._v(" "),e("p",[s._v("如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。")]),s._v(" "),e("p",[e("strong",[s._v("恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。")])]),s._v(" "),e("p",[s._v("本文只是基于自己的理解讲了理论知识，因为对后端知识不是很熟，如有谬误，还请告知，万分感谢！")])])}),[],!1,null,null,null);o.default=_.exports}}]);